#!/usr/bin/env python

"""
### Robot battery
Battery node that depletes as the robot moves, and charges up when in charging station

    Publisher:
        battery level
    Subscriber:
        robot location

    PO: If robot_status is charging, we charge up battery. Although, there should be delay in charging
    How will we be able to capture the delay?
    PO: Subscriber to robot status. If charging, then battery will be charged up though over some delay.
"""

from enum import Enum
import math
import rospy
from std_msgs.msg import Float32, Int8
import project_utils as pu


class robotStatus(Enum):
    IDLE = 10
    READY = 11
    THINKING = 12
    IN_MISSION = 20
    CHARGING = 30
    RESTORING_F = 40

class Battery():
    IDLE = 0
    DEPLETING = 1
    CHARGING = 10
    FULLY_CHARGED = 11

    def __init__(self, node_name):
        #Params
        rospy.init_node(node_name)
        self.robot_id = rospy.get_param('~robot_id')
        self.max_battery = rospy.get_param("/max_battery")
        self.restoration = rospy.get_param("/restoration")
        self.batt_depletion, self.batt_restoration = rospy.get_param("/batt_consumed_per_time")

        #Publisher/subscriber
        rospy.Subscriber("/robot_{}/robot_status".format(self.robot_id), Int8, self.robot_status_cb)
        self.battery_pub = rospy.Publisher("/robot_{}/battery".format(self.robot_id), Float32, queue_size=1)
        self.battery_status_pub = rospy.Publisher("/robot_{}/battery_status".format(self.robot_id), Int8, queue_size=1)

        #Init values
        self.battery = self.max_battery
        self.status = self.IDLE

    def robot_status_cb(self, msg):
        """
        Callback to robot status. Here we update the battery status as either charging or depeting depending on the robot status
        :return:
        """
        robot_status = msg.data
        if robot_status == robotStatus.IDLE.value or robot_status == robotStatus.READY.value or robot_status == robotStatus.THINKING.value:
            self.status = self.IDLE
        elif robot_status == robotStatus.IN_MISSION.value or robot_status == robotStatus.RESTORING_F.value:
            self.status = self.DEPLETING
        elif (robot_status == robotStatus.CHARGING.value) and (self.battery < self.max_battery):
            self.status = self.CHARGING
        pu.log_msg('robot', self.robot_id, 'robot status: {}. battery status: {}'.format(robot_status, self.status))

    def charge_delay(self):
        """
        Delay in restoring F-measure back to max level
        :return:
        """
        delay = int(math.ceil(self.batt_restoration * (self.max_battery - self.battery)))
        return delay

    def run_operation(self, freq_hz=1):
        rate = rospy.Rate(freq_hz)
        while not rospy.is_shutdown():
            self.publish_battery()
            if self.status == self.IDLE:
                pass

            elif self.status == self.DEPLETING:
                self.battery -= self.batt_depletion

            elif self.status == self.CHARGING:
                delay = self.charge_delay()
                for i in range(delay):
                    self.battery += self.batt_restoration
                    rate.sleep()
                self.battery = self.max_battery
                self.status = self.FULLY_CHARGED

            elif self.status == self.FULLY_CHARGED:
                pass

            rate.sleep()

    def publish_battery(self):
        """
        Publishes battery level as a Float topic and status as Int topic
        :return:
        """
        self.battery_pub.publish(self.battery)
        self.battery_status_pub.publish(self.status)

if __name__ == '__main__':
    Battery('battery').run_operation(1)
